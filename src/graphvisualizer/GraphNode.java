package graphvisualizer;

import SwingElements.Base;
import SwingElements.Canvas;
import java.awt.Color;
import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.Random;

/**
 * Nodes on the grid. Each one has a list of connected nodes.
 */
public class GraphNode extends Rectangle {

    //Colors for nodes
    public static final Color DEFAULT_COLOR = Color.blue;
    public static final Color DEFAULT_EDGE_COLOR = Color.black;
    public static final Color DEFAULT_MIDDLE_COLOR = Color.darkGray;
    public static final Color SELECTED_COLOR = Color.green;
    public static final Color SELECTED_ADJACENT_COLOR = Color.cyan;
    public static final Color LINE_EVENT_NODE1_COLOR = Color.yellow;
    public static final Color LINE_EVENT_NODE1_ADJACENT_COLOR = new Color(200, 200, 0);
    public static final Color LINE_EVENT_NODE2_COLOR = Color.orange;

    private final ArrayList<GraphTuple> connections = new ArrayList<>();    //Node-specific adjacency list. GraphTuple items hold both nodes, as well as other information
    //  This node is the fromLocation, while the other node is the toLocation
    private final int id;                                                   //Node ID #
    private final int iLoc;                                                 //Y-axis coordinate
    private final int jLoc;                                                 //X-axis coordinate
    private int food;                                                       //The amount of food this node currently has
    private final int foodVar = 10;                                         //The maximum amount of food the node can start with
    private final int regenVar = 3;                                         //The maximum rate at which this the regenerates food each turn
    private final int regenThreshold = 1;                                   //The minimum amount of food required for the node to regenerate food
    private int regenRate;                                                  //The rate at which the node regenerates food
    private Color color;                                                    //The color of the node. Should only be one of the static color variables

    /**
     * @param xloc The xLocation on the {@link Canvas} object
     * @param yloc The yLocation on the {@link Canvas} object
     * @param width The display width of the node on the {@link Canvas} object
     * @param height The display height of the node on the {@link Canvas} object
     * @param id The ID of the node, generated by the {@link Graph} object
     * @param iLoc The Y coordinate of the node in the {@link Graph} matrix
     * @param jLoc The X coordinate of the node in the {@link Graph} matrix
     * @param food Determines if the node should be given a random amount of
     * food
     */
    public GraphNode(int xloc, int yloc, int width, int height, int id, int iLoc, int jLoc, boolean food) {
        super(xloc, yloc, width, height);
        if (food) {
            Random rand = new Random();
            this.food = rand.nextInt(foodVar);
            this.regenRate = rand.nextInt(regenVar);
        }//end if
        else {
            this.food = 50;
        }//end else
        this.id = id;
        this.iLoc = iLoc;
        this.jLoc = jLoc;
    }//end constructor

    /**
     * Connects the node to another, using elements from a given
     * {@link GraphTupleInfo} object
     *
     * @param to The {@link GraphNode} to connect to
     * @param gti The {@link GraphTupleInfo} to get connection information from
     * @return True if successful, false if not
     */
    public boolean connect(GraphNode to, GraphTupleInfo gti, int direction, double severity, boolean redundant) {
        if (!isConnected(to)) {
            GraphTuple newConnection = new GraphTuple(to, this, gti);
            if (Canvas.curveEnabled) {
                newConnection.generateCurve(direction, severity);
                newConnection.redundant = redundant;
            }//end if
            connections.add(newConnection);
            return true;
        }//end if
        return false;
    }//end connect

    /**
     * Regenerates food on this node
     */
    public void regenFood() {
        food += regenRate;
    }//end regenFood

    /**
     * Prints the node ID, along the IDs of connected nodes
     */
    public void print() {
        System.out.println("This node id: " + id);
        System.out.println("Connected ids: ");
        for (GraphTuple gt : connections) {
            System.out.print(gt.getToLocation().id + " ");
        }//end for
        System.out.println();
    }//end print

    /**
     * Returns a string of node coordinates, in the format x,y
     *
     * @return A string, containing the x and y coordinates for the node
     */
    public String printCoordinates() {
        return (jLoc + "," + iLoc);
    }//end printCoordinates

    /**
     * Maps the node to new coordinates determined by click-and-drag on the
     * {@link Canvas}
     *
     * @param x The change in the {@link Canvas} x axis
     * @param y The change in the {@link Canvas} y axis
     * @return A rectangle with the new coordinates, to be displayed on the
     * {@link Canvas} object
     */
    public Rectangle mapMovement(int x, int y) {
        return new Rectangle(this.x + x, this.y + y, this.width, this.height);
    }//end mapMovement

    /**
     * Checks if a given node is present in the node's adjacency list
     *
     * @param target The node to check for
     * @return True if target is in the adjacency list, false if not
     */
    public boolean isConnected(GraphNode target) {
        for (GraphTuple gt : connections) {
            if (gt.getToLocation() == target) {
                return true;
            }//end if
        }//end for
        return false;
    }//end isConnected

    /**
     * Returns the first connection to this node, the "parent" connection
     *
     * @return The first {@link GraphTuple} object in the adjacency list.
     */
    public GraphTuple getParentLine() {
        return connections.get(0);
    }//end getParentLine

    /**
     * Gets the connection in the node's adjacency list at the given index
     *
     * @param i The index of the node to be retrieved
     * @return The {@link GraphTuple} object at the given index in the adjacency
     * list
     */
    public GraphTuple getConnection(int i) {
        return connections.get(i);
    }//end getConnection

    /**
     * Gets the connection leading to a given node
     *
     * @param gn The node to be looked for
     * @return The {@link GraphTuple} object connecting the node to the given
     * node. Returns null if no such connection exists
     */
    public GraphTuple getConnection(GraphNode gn) {
        for (GraphTuple gt : connections) {
            if (gt.getToLocation() == gn) {
                return gt;
            }//end if
        }//end for
        return null;
    }//end getConnection

    /**
     * Removes the node's connection with a given node, on both nodes
     *
     * @param gn The node to sever the connection with
     */
    public void severConnection(GraphNode gn) {
        if (isConnected(gn)) {
            for (int i = 0; i < connections.size(); i++) {
                if (connections.get(i).getToLocation() == gn) {                 //Uses toLocation because hte node calling severConnection is always the fromLocation
                    connections.remove(i);
                    break;
                }//end if
            }//end for
        }//end if
    }//removeConnection

    /**
     * Removes all connections from the node, and removes the node from the
     * adjacency lists of all connected nodes
     */
    public void clearConnections() {
        for (int i = 0; i < connections.size(); i++) {
            GraphTuple gt = connections.get(i);
            if (!gt.isEdge(Base.graph)) {
                Base.graph.disconnect(gt.getFromLocation(),gt.getToLocation());
                i--;
            }//end if
        }//end for
    }//end clearConnections

    /**
     * Gets the number of connections the node has
     *
     * @return The number of connections the node has
     */
    public int getNumberOfConnections() {
        return connections.size();
    }//end getNumberOfConnections

    /**
     * Compares the X values of the node, and the toLocation of its parent
     * {@link GraphTuple}
     *
     * @return The distance between the X values of the node and the toLocation
     * of its parent {@link GraphTuple}
     */
    public int compareX() {
        return jLoc - getParentLine().getToLocation().getJLoc();
    }//end compareX

    /**
     * Compares the Y values of the node, and the toLocation of its parent
     * {@link GraphTuple}
     *
     * @return The distance between the Y values of the node and the toLocation
     * of its parent {@link GraphTuple}
     */
    public int compareY() {
        return iLoc - getParentLine().getToLocation().getILoc();
    }//end compareX

    /**
     * Checks if the given node is adjacent to the node. Adjacent nodes are no
     * more than one space away in any direction
     *
     * @param in The node to check for adjacency to
     * @return True if the given node is adjacent to the node, false if not
     */
    public boolean isAdjacentTo(GraphNode in) {
        int i = Math.abs(in.getILoc() - iLoc);
        int j = Math.abs(in.getJLoc() - jLoc);
        return ((i == 1 && j == 1) || (i == 1 && j == 0) || (i == 0 && j == 1));
    }//end isAdjacentTo

    /**
     * Reduces food amount by the number of connections involving this node
     *
     * @param graph The {@link Graph} object to check edges against
     */
    public void consume(Graph graph) {
        for (GraphTuple gt : connections) {
            if (!gt.isEdge(graph)) {                    //Only non-edge connections should reduce node food count
                food--;
            }//end if
            if (food < 0) {                             //Food should never go negative
                food = 0;
            }//end if
            if (food >= regenThreshold) {
                regenFood();
            }//end if
        }//end for
    }//end consume

    //////////////////////////////
    //     Setters/Getters      //
    //////////////////////////////
    //TODO: Replace with Enum for color
    /**
     * Sets the color of the node, using a {@link Color} object. Should only use
     * the static color variables for {@link GraphNode}s
     *
     * @param in The new color for the node
     */
    public void setColor(Color in) {
        color = in;
    }//end setColor

    /**
     * Sets the color of the node, using RGB values. Should not be used unless
     * necessary. Instead use static {@link GraphNode} Color variables
     *
     * @param rin
     * @param bin
     * @param gin
     */
    public void setColor(int rin, int bin, int gin) {
        color = new Color(rin, gin, bin);
    }//end setColor

    /**
     * Gets the color of the node
     *
     * @return The current color of the node
     */
    public Color getColor() {
        return color;
    }//end getColor

    /**
     * Gets the remaining amount of food for the node
     *
     * @return The food remaining on the node
     */
    public int getFood() {
        return food;
    }//end getFood

    /**
     * Gets the I, or Y axis, location of the node in the {@link Graph} object
     * matrix
     *
     * @return The I value for the node
     */
    public int getILoc() {
        return iLoc;
    }//end getILoc

    /**
     * Gets the J, or X axis, location of the node in the {@link Graph} object
     * matrix
     *
     * @return The J value for the node
     */
    public int getJLoc() {
        return jLoc;
    }//end getJLoc
}//end GraphNode
